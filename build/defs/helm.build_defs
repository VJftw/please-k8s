"""
Build rules for working with [Helm](https://helm.sh).

The Helm Architecture describes 3 concepts:

> For Helm, there are three important concepts:
> 1. The chart is a bundle of information necessary to create an instance of a
>    Kubernetes application.
> 2. The config contains configuration information that can be merged into a
>    packaged chart to create a releasable object.
> 3. A release is a running instance of a chart, combined with a specific
>    config.

The build definitions defined in this file consider these concepts whereby:

* The `helm_chart` build definition implements 1). and 2). by outputting Helm
  Chart packages with the given configuration.
* The `helm_release` build definition implements 3). by enabling users to
  specify many running instances of a given `helm_chart` or `remote_file`'d Helm
  Chart with per release specific configuration as code.
"""

DEFAULT_LABELS=["helm"]

def helm_chart(
    name: str,
    chart_type: str = "application",
    description: str = "A Helm chart for Kubernetes.",
    app_version: str = "0.0.0",
    src_templates: list = [],
    src_values: str = "",
    subcharts: list = [],
    labels: list = [],
    visibility: list = [],
    images: list = [],
):
    """
    Build rule for creating Helm Charts.

    A chart is a collection of files that describe a related set of Kubernetes
    resources. A single chart might be used to deploy something simple, like a
    memcached pod, or something complex, like a full web app stack with HTTP
    servers, databases, caches, and so on.

    https://helm.sh/docs/topics/charts/

    This build rule outputs the Helm Chart as a packaged chart versioned as
    development and tagged with a digest of the inputs as per the Semver 2.0
    spec:
        `0.0.0+<sh256sum of inputs>`

    > https://semver.org/spec/v2.0.0.html
    > 4. Major version zero (0.y.z) is for initial development. Anything MAY
    >    change at any time. The public API SHOULD NOT be considered stable.
    > 10. Build metadata MAY be denoted by appending a plus sign and a series of
    >     dot separated identifiers immediately following the patch or
    >     pre-release version. Identifiers MUST comprise only ASCII
    >     alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty.
    >     Build metadata MUST be ignored when determining version precedence.
    >     Thus two versions that differ only in the build metadata, have the
    >     same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
    >     1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3â€”-117B344092BD.

    Additional tooling should be used to promote a development Helm Chart into
    a non-development, released version.

    Args:
        name: The name of the Helm Chart.
        chart_type: The type of the Helm Chart. Either "application" or
                    "library". Defaults to "application".
        description: The description of the Helm package.
        app_version: The application version of the Helm package.
        src_templates: The files to use as templates. These will be placed in
                       the templates/ folder.
        src_values: The values file to use to use as default values.
        subcharts: The subcharts for this Helm chart.
        labels: Additional Please labels.
        visibility: The Please targets to make this Helm package visibile to.
        images: The Please 'image' targets that this Helm Chart uses. These
                should have a `_push` subrule what will be used to push them
                before the Helm Chart is installed/upgraded. The `_push` subrule
                must satisfy the same functionality as provided by the
                `VJftw/please-buildkit` build definitions. A more formal API
                will be defined in a future version of this plugin.
    """
    assert chart_type in ["application", "library"], f"{chart_type} is an invalid chart_type."
    images = [canonicalise(img) for img in images]

    helm_tool = CONFIG.K8S.HELM_TOOL
    labels += DEFAULT_LABELS

    srcs_values = []
    if src_values:
      srcs_values += [src_values]

    context=tarball(
        name = f"_{name}#context.tar",
        srcs = src_templates + srcs_values + subcharts,
    )

    chart_yaml=genrule(
        name = f"_{name}#chart.yaml",
        srcs = [context],
        outs = [f"_{name}#chart.yaml"],
        cmd = f"""
version="$(echo "$(sha256sum $SRCS | cut -f1 -d" " | cut -c1-7)")"
cat <<EOF > $OUTS
apiVersion: v2
name: "{name}"
description: "{description}"
type: "application"
version: 0.0.0+$version
appVersion: "{app_version}"
EOF
        """,
    )

    image_labels=[f"image:{img}" for img in images]

    package=genrule(
        name = name,
        srcs = {
            "chart_yaml": [chart_yaml],
            "templates": src_templates,
            "values": srcs_values,
            "subcharts": subcharts,
        },
        # output_dirs = ["outs"],
        outs = [f"{name}.tgz"],
        cmd = f"""
        set -e
        chart_dir="$(mktemp -d)"
        chart_yaml_path="$SRCS_CHART_YAML"
        expected_chart_yaml_path="${{chart_dir}}/Chart.yaml"
        mv "$chart_yaml_path" "$expected_chart_yaml_path"

        # shift templates into templates/
        if [ -n "${{SRCS_TEMPLATES:-}}" ]; then
            mkdir -p "${{chart_dir}}/templates"
            for tmpl in $SRCS_TEMPLATES; do
                cp -r "$tmpl" "${{chart_dir}}/templates/"
            done
        fi

        # shift values to values.yaml
        if [ -n "${{SRCS_VALUES:-}}" ]; then
            cp "$SRCS_VALUES" "${{chart_dir}}/values.yaml"
        fi

        # shift subcharts into charts directory
        if [ -n "${{SRCS_SUBCHARTS:-}}" ]; then
            echo "dependencies:" >> "$expected_chart_yaml_path"
            mkdir -p "${{chart_dir}}/charts"
            for subchart in $SRCS_SUBCHARTS; do
                subchart_name="$($TOOL show chart $subchart | grep "^name:" | cut -f2 -d: | xargs)"
                subchart_version="$($TOOL show chart $subchart | grep "^version:" | cut -f2 -d: | xargs)"
                echo "- name: $subchart_name\n  version: $subchart_version" >> "$expected_chart_yaml_path"
                mv "$subchart" "${{chart_dir}}/charts/"
            done
        fi

        mkdir -p outs/
        $TOOL package "${{chart_dir}}" && mv *.tgz $OUTS
        """,
        tools = [helm_tool],
        labels = labels + ["helm_chart"] + image_labels,
        visibility = visibility,
    )

    sh_cmd(
        name = f"{name}_lint",
        data = [package, helm_tool],
        shell = "/usr/bin/env bash",
        cmd = f"""
set -Eexuo pipefail
$(out_exe {helm_tool}) lint $(out_location {package})
        """,
        labels = ["lint"] + labels,
        visibility = visibility,
    )

    for show_cmd in [
        "chart",
        "crds",
        "readme",
    ]:
        sh_cmd(
            name = f"{name}_show_{show_cmd}",
            data = [package, helm_tool],
            shell = "/usr/bin/env bash",
            cmd = f"""
set -Eexuo pipefail
$(out_exe {helm_tool}) show {show_cmd} $(out_location {package})
            """,
            labels = labels + [f"helm_show_{show_cmd}"]
        )

    return package

def helm_remote_chart(
    name: str,
    url: str,
    hashes: list = [],
    licences: list = [],
    labels: list = [],
    visibility: list = [],
    images: list = [],
):
    """
    Build rule for fetching remote Helm Charts to use with Please.

    This build rule fetches the given packaged the Helm Chart and adds the given
    images as dependencies for it. This allows you to utilise the benefits of
    Please with external Helm Charts.

    Args:
        name: The name of the Helm Chart.
        url: The url for the external Helm Chart. Must end in `.tgz`.
        licences: The licences associated with the Helm Chart.
        labels: Additional Please labels.
        visibility: The Please targets to make this Helm package visibile to.
        images: The Please 'image' targets that this Helm Chart uses. These
                should have a `_push` subrule what will be used to push them
                before the Helm Chart is installed/upgraded. The `_push` subrule
                must satisfy the same functionality as provided by the
                `VJftw/please-buildkit` build definitions. A more formal API
                will be defined in a future version of this plugin.
    """
    helm_tool = CONFIG.K8S.HELM_TOOL

    image_labels=[f"image:{img}" for img in images]

    package=remote_file(
        name = name,
        url = url,
        hashes = hashes,
        licences = licences,
        labels = labels + image_labels,
        visibility = visibility,
        exported_deps = images,
    )

    for show_cmd in [
        "chart",
        "crds",
        "readme",
        "values",
    ]:
        sh_cmd(
            name = f"{name}_show_{show_cmd}",
            data = [package, helm_tool],
            shell = "/usr/bin/env bash",
            cmd = f"""
set -Eexuo pipefail
$(out_exe {helm_tool}) show {show_cmd} $(out_location {package})
            """,
            labels = labels + [f"helm_show_{show_cmd}"]
        )

    return package

def helm_release(
    name: str,
    src_chart: str,
    kube_context: str = "",
    namespace: str = "default",
    atomic: bool = True,
    create_namespace: bool = True,
    description: str = "",
    force: bool = False,
    timeout: str = "5m0s",
    wait: bool = True,
    wait_for_jobs: bool = True,
    values_files: list = [],
    post_renderer: str = "",
    post_renderer_args: list = [],
    image_pusher: str = "",
    image_pusher_args: str = [],
    labels: list = [],
    visibility: list = [],
):
    """
    Build rule for installing and managing Helm Charts as Releases.

    Args:
        name: The name of the Helm Release.
        src_chart: The target which outputs the Helm Chart as a `.tgz`.
        kube_context: The Kubernetes context to use from kubeconfig. If a Please
                      Target is passed to this, it must implement the following
                      subrules:
                        - `:_{name}#kube_context`:
                            A binary which prints the Kubernetes Context name to
                            use. This may be used for authentication before
                            `helm` is called.
                        - `:_{name}#image_pusher`:
                            A binary which pushes images before `helm` is
                            called. It should accept a list of image Please
                            targets as positional arguments.
                        - `:_{name}#helm_post_renderer`:
                            A binary to be used as a post-renderer to the `helm`
                            command. This should implement the post-rendering
                            API provided by the Helm documentation.
                            (https://helm.sh/docs/topics/advanced/#post-rendering).
                       The following Environment Variables are set:
                        - `IMAGE_TARGETS`:
                           A space-separated list of canonical Please
                           targets which represent the images associated
                           with the Helm chart.

        namespace: The namespace to deploy the Helm Release to.
        atomic: If True, upgrade process rolls back changes made in case of
                failed upgrade. The --wait flag will be set automatically if
                --atomic is used.
        create_namespace: Create the release namespace if not present.
        description: Add a custom description.
        force: Force resource updates through a replacement strategy.
        timeout: Time to wait for any individual Kubernetes operation (like Jobs
                 for hooks) (default 5m0s).
        wait: If True, will wait until all Pods, PVCs, Services, and minimum
              number of Pods of a Deployment, StatefulSet, or ReplicaSet are in
              a ready state before marking the release as successful. It will
              wait for as long as `timeout`.
        wait_for_jobs: If True and --wait enabled, will wait until all Jobs have
                       been completed before marking the release as successful.
                       It will wait for as long as --timeout.
        values_files: Custom values files to use when installing or templating
                      the package.
        labels: Additional Please labels.
        visibility: The Please targets to make this Helm package visibile to.
    """
    helm_tool = CONFIG.K8S.HELM_TOOL

    labels += DEFAULT_LABELS

    if kube_context.startswith(":"):
        kube_context = canonicalise(kube_context)

    values_files_targets = _helm_release_values_files_targets(values_files)

    _helm_release_template_test(
        name,
        helm_tool,
        src_chart,
        values_files_targets,
        labels,
    )

    _helm_release_deploy(
        name,
        helm_tool,
        src_chart,
        values_files_targets,
        kube_context,
        namespace,
        atomic,
        create_namespace,
        description,
        force,
        timeout,
        wait,
        wait_for_jobs,
        labels,
        visibility,
    )

    _helm_release_uninstall(
        name,
        helm_tool,
        kube_context,
        namespace,
        description,
        timeout,
        wait,
        labels,
        visibility,
    )

    _helm_release_template(
        name,
        helm_tool,
        src_chart,
        values_files_targets,
        kube_context,
        labels,
        visibility,
    )

def _helm_release_values_files_targets(values_files: list):
    """
    Returns the given values files as a list of Please targets, creating new
    Please targets as necessary.
    """
    values_files_targets=[]
    for trgt in values_files:
        if not (trgt.startswith("//") or trgt.startswith(":")):
            trgt=export_file(
                name = f"values_{trgt}",
                src = trgt,
            )

        values_files_targets += [canonicalise(trgt)]

    return values_files_targets


def _helm_release_template_test(
    name: str,
    helm_tool: str,
    src_chart: str,
    values_files_targets: list,
    labels: list,
):
    """
    Tests whether or not the Helm Release will template succesfully with the
    given values files.
    """
    values_files_test_flags = [f"-f $(location {f})" for f in values_files_targets]
    values_files_test_cmd = " ".join(values_files_test_flags)

    return gentest(
        name = f"{name}_template_test",
        data = [src_chart] + values_files_targets,
        test_cmd = f"""
set -Eexuo pipefail
$TOOL template --debug $(location {src_chart}) {values_files_test_cmd}
        """,
        no_test_output = True,
        test_tools = [helm_tool],
        labels = labels + ["helm_template_test"],
    )

def _helm_release_deploy(
    name: str,
    helm_tool: str,
    src_chart: str,
    values_files_targets: list,
    kube_context: str,
    namespace: str,
    atomic: bool,
    create_namespace: bool,
    description: str,
    force: bool,
    timeout: str,
    wait: bool,
    wait_for_jobs: bool,
    labels: list,
    visibility: list,
):
    values_files_flags = [f"--values $(out_location {f})" for f in values_files_targets]

    data = [src_chart, helm_tool] + values_files_targets

    pre_build_functions = [_set_image_targets]

    helm_args=[
        f"$(out_exe {helm_tool})",
        "upgrade",
        name,
        f"$(out_location {src_chart})",
        "--install",
        "--namespace", namespace,
    ] + values_files_flags

    if kube_context:
        helm_args+=_get_kube_context_args(kube_context, "upgrade")
        data+=_get_kube_context_data(kube_context, "upgrade")
    if atomic:
        helm_args+=["--atomic"]
    if create_namespace:
        helm_args+=["--create-namespace"]
    if description:
        helm_args+=["--description", description]
    if helm_args:
        helm_args+=["--force"]
    if timeout:
        helm_args+=["--timeout", timeout]
    if wait:
        helm_args+=["--wait"]
    if wait_for_jobs:
        helm_args+=["--wait-for-jobs"]

    helm_cmd = " ".join(helm_args)

    image_pusher_cmd=""
    if kube_context.startswith("//"):
        image_pusher_target=_canonical_tag(kube_context, "image_pusher")
        image_pusher_cmd=f"$(out_exe {image_pusher_target})"
        data+=[image_pusher_target]

    genrule(
        name = f"{name}_deploy",
        outs = [f"{name}_deploy.sh"],
        pre_build = lambda rule: [fn(rule, src_chart) for fn in pre_build_functions],
        data = data,
        binary = True,
        cmd = f"""
cat <<EOF > $OUTS
#!/usr/bin/env bash
set -Eeuo pipefail
export IMAGE_TARGETS=""
{image_pusher_cmd}
set -x
{helm_cmd} \\\$@
EOF
        """,
        labels = labels + ["helm_deploy", "helm_release", kube_context],
    )

def _set_image_targets(rule_name, src_chart):
    image_labels = get_labels(src_chart, "image:", False)
    image_targets = [lbl.removeprefix("image:") for lbl in image_labels]
    image_targets_bash_arr = " ".join(image_targets)
    cmd = get_command(rule_name)
    new_cmd = cmd.replace('IMAGE_TARGETS=""', f'IMAGE_TARGETS="{image_targets_bash_arr}"')
    set_command(rule_name, new_cmd)

def _get_kube_context_args(kube_context: str, helm_cmd: str):
    if not kube_context:
        return []

    if kube_context.startswith("//"):
        args = []
        if helm_cmd in ["upgrade", "uninstall"]:
            kube_context_target=_canonical_tag(kube_context, "kube_context")
            args += ["--kube-context", f"\\\$($(out_exe {kube_context_target}))"]

        if helm_cmd in ["upgrade", "template"]:
            post_renderer_target=_canonical_tag(kube_context, "helm_post_renderer")
            args += ["--post-renderer", f"$(out_exe {post_renderer_target})"]

        return args

    return ["--kube-context", kube_context]

def _get_kube_context_data(kube_context: str, helm_cmd: str):
    if not kube_context:
        return []

    if kube_context.startswith("//"):
        data = []
        if helm_cmd in ["upgrade", "uninstall"]:
            kube_context_target=_canonical_tag(kube_context, "kube_context")
            data += [kube_context_target]

        if helm_cmd in ["upgrade", "template"]:
            post_renderer_target=_canonical_tag(kube_context, "helm_post_renderer")
            data += [post_renderer_target]

        return data

    return []

def _helm_release_uninstall(
    name: str,
    helm_tool: str,
    kube_context: str,
    namespace: str,
    description: str,
    timeout: str,
    wait: bool,
    labels: list,
    visibility: list,
):
    args=[
        f"$(out_exe {helm_tool})",
        "uninstall",
        name,
        "--namespace", namespace,
    ]

    data = []

    if kube_context:
        args+=_get_kube_context_args(kube_context, "uninstall")
        data+=_get_kube_context_data(kube_context, "uninstall")
    if description:
        args+=["--description", description]
    if timeout:
        args+=["--timeout", timeout]
    if wait:
        args+=["--wait"]

    cmd = " ".join(args)

    return sh_cmd(
        name = f"{name}_uninstall",
        data = [helm_tool] + data,
        shell = "/usr/bin/env bash",
        cmd = f"""
set -Eexuo pipefail
{cmd} \\\$@
        """,
        labels = labels + ["helm_uninstall", "helm_release", kube_context],
    )

def _helm_release_template(
    name: str,
    helm_tool: str,
    src_chart: str,
    values_files_targets: list,
    kube_context: str,
    labels: list,
    visibility: list,
):
    values_files_flags = [f"--values $(out_location {f})" for f in values_files_targets]

    data = [src_chart, helm_tool] + values_files_targets

    pre_build_functions = [_set_image_targets]

    args=[
        f"$(out_exe {helm_tool})",
        "template",
        name,
        f"$(out_location {src_chart})",
    ] + values_files_flags

    if kube_context:
        args+=_get_kube_context_args(kube_context, "template")
        data+=_get_kube_context_data(kube_context, "template")

    cmd = " ".join(args)

    genrule(
        name = f"{name}_template",
        outs = [f"{name}_template.sh"],
        pre_build = lambda rule: [fn(rule, src_chart) for fn in pre_build_functions],
        data = data,
        binary = True,
        cmd = f"""
cat <<EOF > $OUTS
#!/usr/bin/env bash
set -Eeuo pipefail
export IMAGE_TARGETS=""
set -x
{cmd} \\\$@
EOF
        """,
        labels = labels + ["helm_template"],
    )

def _canonical_tag(label: str, tag_str: str):
    pkg, name = decompose(label)
    tagged_name = tag(name, tag_str)
    if pkg == "":
        return canonicalise(f":{tagged_name}")
    return f"//{pkg}:{tagged_name}"
